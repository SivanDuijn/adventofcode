// https://adventofcode.com/2022/day/7

use std::{collections::HashMap, hash::Hash};

use advent_of_code_2022::split;

struct Directory {
    files: Option<usize>,
    parent: Option<usize>,
    dirs: Option<usize>,
}

fn parse(input: &str) -> HashMap<String, Directory> {
    let lines = split(input, "\n");

    let mut dir_to_index: HashMap<String, usize> = HashMap::new();
    let mut dir_files_list: Vec<Vec<(String, i32)>> = Vec::new();
    let mut dirs_list: Vec<Vec<usize>> = Vec::new();
    let mut dirs: HashMap<String, Directory> = HashMap::new();

    let mut dirs: Vec<Directory> = Vec::new();

    dirs.push(Directory { files: None, parent: None, dirs: None });

    // dirs.insert("root".to_string(), Directory { files: Vec::new(), parent: None, dirs: Vec::new() });

    let mut working_dir: usize = 0;

    for line in lines.iter().skip(1) {
        let args = split(line, "\n");
        
        if args[0] == "$" {
            if args[1] == "ls" {
                continue;
            }
            else if args[1] == "cd" {
                if args[2] == ".." {
                    working_dir = dirs[working_dir].parent.unwrap();
                }
                else {
                    working_dir = dirs_list[working_dir][dir_to_index[args[2]]]dirs[working_dir].dirs.unwrap();
                }
            }
        }
        else if args[0] == "dir" {
            dirs.insert(args[1], Directory { files: Vec::new(), parent: None, dirs: Vec::new() });
        }
        else {
            let size: i32 = args[0].parse().unwrap();
            working_dir.files.push((args[0].to_owned(), size));
        }
    }

    return dirs;
}

fn solve1(parsed_input: &HashMap<String, Directory>) -> String { return "?".to_string(); }

fn solve2(parsed_input: &HashMap<String, Directory>) -> String { return "?".to_string(); }

pub fn solve(input: &str) -> (String, String) {
    let parsed_input = parse(input);
    return (solve1(&parsed_input), solve2(&parsed_input));
}